---
title: "操作系统面试题"
date: 2020-12-02
draft: false
toc: true
categories: ["面试"]
tags: ["操作系统", "面试题"]
---

## 基础
### 什么是操作系统
本质上还是程序, 是管理计算机硬件与软件资源的程序. 它屏蔽了硬件层的复杂性, 提供内存管理/设备驱动/文件系统的管理/应用程序的管理.

### 系统调用
用户态通过中断中断去调用系统态的函数. 系统调用作为动词来讲就是用户去调用系统的功能, 从名字来讲就是系统调用泛指那些调用的函数. 系统调用分为:
- 设备管理: 完成设备的请求或释放, 以及设备启动等功能
- 文件管理: 完成文件的读/写/创建及删除等功能
- 进程控制: 完成进程的创建/撤销/阻塞及唤醒等功能
- 进程通信: 完成进程之间的消息传递或信号传递等功能
- 内存管理: 完成内存的分配/回收以及获取作业占用内存区大小及地址等功能

## 进程与线程
### 区别
从操作系统的角度来看, 进程是操作系统运行的基本单位, 而线程可以看作是进程的细分. 因为cpu只有一个mmu, 内存管理系统, 所以进程切换的时候与之对应的映射表也要切换. 然而对应一些任务来说, 我们需要一份数据被多个任务同时处理, 那么线程的优势就出来了. 线程切换实际上就是就是映射表不变而PC指针变. 而且, 线程分为用户态线程和内核级线程, 其中内核级线程可以充分利用操作系统的多核. 

从JVM的角度来看, 一个运行时数据区对应一个进程, 其中堆和方法区(元空间)被进程共享, 而每个线程都有自己独立的虚拟机栈/局部变量表/PC寄存器/本地方法栈等等. 

**协程**可以视为程序员用代码替代了硬件任务调度, 主动承担了一部分原本由操作系统承担的工作. 无需线程上下文切换的开销, 依然会被i/o阻塞, 因为本质上是单线程(种用户态轻量级线程). 多协程切换没有线程切换的开销, 没有多线程的锁机制, 协程中控制共享资源不加锁, 只需要判断状态. 

### 进程的状态
- 创建态(new): 进程正在被创建, 尚未到就绪状态
- 就绪态(ready): 进程已处于准备运行状态, 即进程获得了除了cpu之外的一切所需资源, 一旦得到cpu资源(处理器分配的时间片)即可运行
- 运行态(running): 进程正在处cpu上运行
- 阻塞态(waiting): 又称为等待状态, 进程正在等待某一事件而暂停运行如等待某资源为可用或等待IO操作完成. 即使处理器空闲, 该进程也不能运行
- 终止态(terminated): 进程正在从系统中消失, 可能是进程正常结束或其他原因中断退出运行

### 进程调度算法
先到先服务调度算法->短作业优先. FCFS->SJF. 平均周转时间减少, 比如一个任务时间为1, 一个为2, 那么$(1 + 3)/2 < (2 + 3)/2$.

时间片轮转调度算法(Round robin)把进程分成时间片, 给每个进程分配时间片, 在该时间片内让进程运行. 当时间片大, 响应时间就会变长, 时间片小, 吞吐量就会变小.

可以让前台任务RR, 后台SJF, 总体上按照**优先级调度**. 优先级必须是动态的, 否则高优先级进程可能使得低优先级进程无法运行, 发生饥饿. 

### 进程通信方式
- 信号量: 整形数字, 用于多进程对共享数据的访问, 信号量的意图在于进程间同步
- socket: 客户端和服务器之间通过网络进行通信
- 有名管道: 匿名管道由于没有名字, 只能用于亲缘关系的进程间通信, 通过提出了有名管道解决这个问题. 有名管道严格遵循先进先出(first in first out). 有名管道以磁盘文件的方式存在, 可以实现本机任意两个进程通信.
- 消息队列: 消息队列可以实现消息的随机查询, 消息不一定要以先进先出的次序读取, 也可以按消息的类型读取. 比 FIFO更有优势

### 线程同步方式
- 信号量: 控制同一时刻访问资源的最大线程数量
- 互斥量: 信号量的一种, 只有拥有互斥对象的线程才有访问公共资源的权限. 比如synchronized关键词和各种Lock.
- 事件(Event): Wait/Notify.

## 内存管理
### 内存管理机制
- 分块: 最早的. 将内存分为几个固定大小的块, 每个块中只包含一个进程, 会浪费很多未利用空间
- 分段: 常见于虚拟内存, 方便用户操作. 操作系统通过重定位, 把虚拟地址映射到物理地址; 对应段表
- 分页: 实际的物理内存, 如果一页只有4k, 那么最多浪费4k; 对应页表

### 快表和多级页表
根据虚拟地址中的页号查快表, 如果该页在快表中, 直接从快表中读取相应的物理地址. 如果该页不在快表中, 就访问内存中的页表, 再从页表中得到物理地址, 同时将页表中的该映射表项添加到快表中. 快表满了, 就按淘汰策略淘汰一页. 可以把快表理解为一种特殊的高速缓冲存储器.

多级页表的主要目的是为了避免把全部页表一直放在内存中占用过多空间, 一些逻辑地址在需要的时候才加入页表项, 这样又会造成页表项不连续. 所以用页目录表+页表, 分级查找.

### 分段分页区别
- 共同: 提高内存利用率, 较少内存碎片. 虽然页和段都是离散存储的, 但是每个页和段中的内存是连续的.
- 区别: 页的大小是固定的, 由操作系统决定; 段的大小不固定, 取决于我们当前运行的程序. 

### CPU寻址
CPU需要将虚拟地址翻译成物理地址, 这样才能访问到真实的物理内存, 通过MMU. 不能直接访问物理地址, 也保证了操作系统的安全. 

### 虚拟内存
它定义了一个连续的虚拟地址空间, 并且把内存扩展到硬盘空间, 所以需要换入换出. 

换入换出一般有LRU, LFU, FIFO算法. 现实情况一般使用Clock算法, 因为开销小, 给每个页加一个引用位, 每次访问一页时, 硬件自动设置该位. 是1时清0, 并继续扫描, 本来就是0时淘汰该页. 也就是说从最近最少访问近似成了最近没有访问. 这就是Clock算法. 有的时候会用快慢指针, 快指针清除1, 防止历史信息遗留过长, 而慢指针选择淘汰页.

## 设备驱动与文件系统
一切都是文件, 操作设备的时候实际上也是进行文件的读写. 

## 参考
1. [JavaGuide-操作系统](https://github.com/Snailclimb/JavaGuide/blob/master/docs/operating-system/basis.md)
2. [JavaGuide-Linux](https://github.com/Snailclimb/JavaGuide/blob/master/docs/operating-system/linux.md)
3. 操作系统-李志军
4. [线程、进程、协程-小歪](https://zhuanlan.zhihu.com/p/70256971)