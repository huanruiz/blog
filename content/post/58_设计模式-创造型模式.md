---
title: "设计模式-创造型模式"
date: 2021-03-02
draft: false
toc: true
categories: ["程序设计"]
tags: ["设计模式"]
---

## 工厂方法 Factory Method
## 抽象工厂 Abstract Factory
## 建造者 Builder
## 原型 Prototype
## 单例 Singleton
保证一个类仅有一个实例, 并提供一个访问它的全局访问点. 也就是说, 用类自身去保存一个`private static final`的实例对象, 而类的构造方法作用域是`private`的, 保证类无法被外部实例化. 而类提供`public static`的`getInstance`的方法. `getInstance`内部new对象就是延迟加载, 当instance为`null`时才加载, 但是必须要加锁(会严重影响性能), 因为多线程情况下依然会创建多个实例. 这个时候可以用**双重锁检查锁(synchronized (Singleton.class))**, 也就是在`instance == null`的时候才加锁, 然后再验证一次`instance`是否为`null`(防止锁释放后, 另一个线程已经new了则个实例), 如果依然为真, 再new这个对象. 可以利用枚举类来实现, 这个枚举类只有一个枚举.

> 枚举类的参数类似`public static final Xxx name = new Xxx();`, 好处是, 枚举类自带类型值. 枚举类可以直接用`==`互相比较, 因为枚举类的每个常量在JVM中只有一个唯一实例. 可以用`name()`取得枚举类常量的名字, `ordinal()`返回常量的顺序(可以通过` MON(1), TUE(2), WED(3), THU(4), FRI(5), SAT(6), SUN(0);`写死顺序, 括号中的数字是构造器的参数, 构造器必须`private`). 字段可以不`final`, 但是一般都要改为常量.

比起静态方法, 单例模式的对象方法可以被重载, 所以对业务相关的逻辑可以用单例解决绝不用静态方法.

### 饿汉式
本身线程安全.
```
class Bank {
    private Bank() {
    }
    private static Bank instance = new Bank();
    private Bank getInstance() {
        return instance;
    }
}
```

### 懒汉式
延迟对象创建. 
```
class Order {
    private Order() { //保证无法在外部实例化
    }
    private static Order instance = null;
    public static Order getInstance() {
        if (instance == null) instance = new Order();
        return instance;
    }
}
```

### 线程安全的懒汉式
```
class Order {
    private Order() {
    }
    private static Order instance = null;
    public static Order getInstance() {
        if (instance == null) {
            synchronized (Order.class) {
                if (instance == null) instance = new Order();
            }
        }
        return instance;
    }
}
```

## 参考
1. [设计模式-廖雪峰](https://www.liaoxuefeng.com/wiki/1252599548343744/1281319090782242)
2. 大话设计模式
3. [尚硅谷](https://www.bilibili.com/video/BV1Kb411W75N?p=325)