---
title: "计算机网络-链路层"
date: 2020-11-09
draft: false
toc: true
categories: ["学习笔记"]
tags: ["计算机网络"]
---

## 概述
运行链路层的主机/路由器/交换机等都叫**结点(node)**, 连接相邻结点的通信信道叫链路. 数据报会被封装到链路层帧中并被传送到链路. 主体部分是网络适配器或者网络接口卡(NIC).

### 链路层提供的服务
1. framing.
2. 链路接入, **medium access control(MAC) protocol**规定帧在链路上的传输规则.
3. 可靠交付, 链路层提供可靠交付服务时, 保证无差错地移动网络层数据报.
4. 差错检测和纠正, 通过硬件提供.

## 多路访问链路和协议
链路层信道有**点对点**和**广播**两种. 对于广播, 当任何一个结点传输一个帧时, 信道就会广播这个帧, 让其他的结点都收到一个副本. 以太网和无线局域网就是广播的应用. 通过多路访问协议来规范它们在共享的广播信道上的传输行为. 具体内容暂时跳过, 主要focus在下一章.

## 交换局域网
在交换局域网中, 交换机运行在链路层, 意味着他们不执行网络层协议(不识别ip地址, 没有路由选择), 只在链路层交换链路层帧.

### 链路层寻址和ARP
**MAC地址**存在于结点的**网络适配器**中. 也叫LAN address/physical addrerss. 对于以太网和802.11无线局域网, MAC地址有6个byte, 对局域网的每个接口来说都是独一无二的(虽然可以通过一些软件来改变, 但是设计上是独一无二的). 前24位由IEEE分配, 后24位由生产主机/路由等结点的公司分配, 来保证唯一性.

**ARP就是地址解析协议**, 可以将IP地址解析为MAC地址, 自然会联想到DNS, 不同的是DNS解析可以在因特网任何地方, 而ARP只能在一个子网上解析. 每台主机或者路由器的内存中会有一个**ARP table**, 包含IP地址到MAC地址的映射和一个TTL值. TTL值表示删除一个映射的时间.

所以, 如果ARP table中本来就有某个表项, 从ip``222.222.222.220``向``222.222.222.222``发送数据报就很容易了, 但是如果没有, 发送方就需要通过ARP协议来解析ip. 同样的例子, ``222.222.222.220``会先向适配器发送ARP查询分组, 并且MAC地址为广播地址``FF-FF-FF-FF-FF-FF-FF``, 这个特殊的**ARP分组**被封装到帧中, 并被传输进子网. ``222.222.222.222``所对应的主机就能返回一个响应ARP分组, ``222.222.222.220``就可以更新ARP表了. 而对于跨子网来说, 路由器会成为连接两个子网的媒介, 先从主机到路由器MAC, 再从路由器到另一个子网某个主机的MAC.
![](/notes/notes9_1.png)

> ARP不仅涵盖了链路层的MAC, 也涵盖了网络层的IP, 所以它实际上是一个跨越链路层和网络层的协议.

### 以太网
以太网帧如下图所示. 以太网服务是无连接, 不可靠的. 即使有CRC检验, 但是如果校验失败也只是丢弃该帧而已. 如果应用基于UDP, 那么接收主机是可以看到因为丢帧带来的**数据间隙**的, 而堆TCP应用来说, 虽然丢帧不直接引起重传, 但是如果TCP需要重传, 意味着datagram其实也重传了, 只是以太网并不知道此.
![](/notes/notes9_2.png)

- 数据字段(46~1500byte): 承载datagram, 1500好理解, 是MTU的最大限制, 而46是数据字段最小长度(也是最小的MTU长度), 如果小于46byte, 就会进行填充. 而网络层解析IP datagram的时候可以根据头中的长度字段来去除填充部分.
- 目的的值(6byte): 目的适配器的MAC地址. 
- 源地址(6byte): 传输该帧的适配器的MAC地址.
- 类型(2byte): 网络层协议的类型, 0x0800表示IP地址.
- CRC(4byte): 循环冗余检测, 接收适配器以此检测帧中是否有差错.
- 前同步码(8byte): 同步发送和接收适配器.

### 链路层交换机
交换机对子网中的主机和路由器是透明的. 他们并不知道交换机的存在. 
1. 交换转发和过滤: **filtering**值判断帧应该转发到某个节后还是将其丢弃, **forwarding**决定帧导向哪个接口. 都借助switch table完成. 表项包括(MAC地址, 交换机接口, 时间). 如果交换机接口x到达了一个帧. 先查表, 如果表中没有对应的地址, 则广播该帧到前面所有的输出缓存. 如果该帧的MAC得知对应的接口还是x, 则过滤掉(丢弃)该帧. 如果对应接口不是x, 则将该帧放到对应接口的输出缓存.
2. 自学习: switch table初始为空, 每个入帧被存储. 当过了**aging time**后, 交换机没有收到该地址作为源地址的帧, 则在表中删除这个地址.
3. 性质: 消除碰撞(集线器不行), 链路彼此隔离, 管理.
4. 比较交换机和路由器, 交换机在第二层, 路由器在第三层. 交换机可以即插即用, 有相对高的分组过滤和转发速率. 但是微课防止广播帧逊汗, 交换网络的拓扑结构限制为生成树. 过大的交换网络会要求主机和路由器由大的ARP表, 造成大量的ARP流量和处理量. 路由的拓扑结构没有限制, 因为有TTL保证不会有过多冗余.

## Web页面请求过程
书本上用张三访问``www.google.com``为例, 过程如下图. 张三将笔记本通过以太网电缆连接到学校的以太网交换机, 而交换机连接着学校的路由器. 学校的路由器连接着ISP``comcast``.
![](/notes/notes9_3.png)

### 准备阶段
张三的笔记本连接以太网后, 需要通过本地的DHCP服务器获得一个ip. 笔记本的操作系统生成DHCP请求报文, 并将其放入UDP segment. 其目的端口是67(DHCP服务器), 源端口是68(DHCP客户). UDP又被放到datagram中, 目的地ip地址是``255.255.255.255``(广播), ip源地址是``0.0.0.0``(因为笔记本还没被分配ip地址). IP datagram被封装到以太网帧中, 以太网帧的目的MAC地址是``FF:FF:FF:FF:FF:FF``, 而源MAC地址就是张三笔记本适配器的``00:16:D3:23:68:8A``. 最终帧通过交换机到达路由器的接口, 层层分解, 直到DHCP请求从UDP segment中抽取出来, 给DHCP服务器. DHCP服务器生成包含这个IP地址/DNS服务器IP``68.87.71.126``/网关路由器IP``68.85.2.1``(包括掩码)的DHCP ACK报文. 再层层向下封装到帧. 源MAC地址是``00:22:6B:45:1F:1B``, 目的MAC地址是``00:16:D3:23:68:8A``. 此时的交换机已经知道了张三笔记本的MAC地址, 所以直接将DHCP ACK的以太网帧从对应的端口发送. 层层向上解析, 得到自己的IP地址和DNS服务器的IP地址. 

### 仍在准备(DNS, ARP)
当张三输入了``www.google.com``的url之后, Web浏览器通过TCP socket, 向``www.google.com``发送HTTP请求, socket需要ip, 而ip会通过DNS得到. 

张三笔记本的os生成DNS查询报文, 将``www.google.com``放入其中, 而DNS报文又会被放到端口是53的UDP segment中, UDP segment的目的地址是``86.87.71.226``, 源地址是``68.85.2.101``. 层层封装到帧中, 在链路层寻址到学校的网关路由器. 因为之前张三的笔记本只通过``DHCP ACK``得到了这个网关路由器的ip地址, 所以现在需要通过ARP去取得对应的MAC地址. 张三笔记本生成一个目的地是``68.85.2.11``的ARP查询报文, 将其放在广播地址``FF:FF:FF:FF:FF:FF``的以太网帧中, 通过交换机发送.  当网关路由器接收到该ARP查询报文的帧, 发现目标地址匹配, 就会进行ARP应答, 封装到以太网帧中, 并向交换机发送, 交换机再交付给张三的笔记本. 张三的笔记本就可以从ARP响应报文中抽取网关路由器的MAC地址.

接下来, 张三的笔记本就能将DNS的以太网帧就能寻址到网关路由器了.

### 仍在准备(域内路由选择到DNS服务器)
网关路由器解析这个帧, 提取帧中DNS查询的IP datagram, 根据datagram的目的地址``68.87.71.226``, 通过转发表转发到Comeast最左侧的路由器. 继续转发, 直到DNS查询到达DNS服务器, 找到对应域名``www.google.com``的ip``64.233.169.105``的DNS源记录. 形成DNS回答报文, 被放入UDP datagram, 向张三的笔记本发送. 张三的笔记本就可以抽取出这个ip地址了.

> 这里书里面没有讲缓存, 实际操作和实验中其实常常会遇到DNS已经被缓存了. 通常会找浏览器缓存, 本机的hosts文件映射, 路由缓存, 最后在才会找DNS服务器.

### Web client -> Server(TCP. HTTP)
Bob的笔记本浏览器通过TCP 生成socket向``www.google.com``发送HTTP GET报文门. 生成socket的时候会三次握手, TCP SYN->TCP SYNACK->ACK. 

google的HTTP服务器收到HTTP GET报文, 生成HTTP响应报文, 把Web页内容放进响应体中, 向Bob的笔记本转发. 最终网页就显示了出来.

## 实验
### Ethernet and ARP
分析原实验的log, uncheck ``Analyze->Enabled Protocols``中的``IPv4``, 因为我们只想看网络层以下的信息.
![](/notes/notes9_4.png)

选择的这一条信息是包含HTTP GET的. host的MAC地址是``00:d0:59:a9:3d:68``, 目的地址是``00:06:25:da:af:73``. 而以太网类型编号``0x0800``表示IPv4. 到G出现在以太网帧共有55byte(两个16进制位相当于一个字节). 

继续看下图中的ARP请求帧. 源地址是``00:80:ad:73:8d:ce``, 目的地址是``ff:ff:ff:ff:ff:ff``. 可以看到ARP所对应的Tpye是``0x0806``. 而Opcode操作码为1. (1是ARP请求, 2是ARP回显, 3是RARP请求, 4是RARP应答). 其中的``192.168.1.1``就是路由器的地址. 而从``Ethernet II``可以看出这是一次广播. 
![](/notes/notes9_5.png)

ARP响应. 此时路由器的MAC地址就知道了. 路由器的MAC地址是``00:06:25:da:af:73``, 而主机的MAC地址是``00:d0:59:a9:3d:68``.
![](/notes/notes9_6.png)

## 参考
1. 计算机网络-自顶向下方法(第6版)
2. Computer Networking A Top-Down Approach(7th edition)
3. [作业](https://github.com/moranzcw/Computer-Networking-A-Top-Down-Approach-NOTES)
4. [习题答案](https://github.com/jzplp/Computer-Network-A-Top-Down-Approach-Answer)
5. [wireshark实验](https://gaia.cs.umass.edu/kurose_ross/wireshark.htm)
6. 程序羊-计算机网络面试题总结